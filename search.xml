<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python 定时任务]]></title>
    <url>%2F2018%2F08%2F20%2Fpython%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[自己写一个定时任务首先创建一个执行时间1sch_time = datetime.datetime(2018,8,20,10,0,0) 写一个函数用来测试定时任务是否执行12def fun(str_msg): print(&quot;hello I&apos;m run&quot;, str_msg) 定时任务的功能12345678910111213141516171819202122def sch_fun(sch_time): flag = 0 #是否执行 run_time = sched_timer.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 转换成统一格式的字符串进行比较 while True: now = datetime.datetime.now() now_time = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 得到当前时间并转换成统一格式的字符串进行比较 if now_time == run_time and flag == 0: fun(&quot;time 1&quot;) # 执行 flag = 1 else: # 上面部分就是定时任务的执行，下面是间隔任务处理 if flag == 1: sched_timer = sched_timer+datetime.timedelta(seconds=5) run_time = sched_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) flag = 0 # 如果执行过了调到下一个执行时间（5秒后) else: if sched_timer &lt;= now: # 调整时间 sched_timer = sched_timer + datetime.timedelta(seconds=5) run_time = sched_timer.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) 然后进行调用就可以运行了 使用schedule这个我感觉不怎么好用（但是比自己写的要好） 就贴上从别人那找来的代码好了123456789101112131415161718192021import scheduleimport time,datetimedef job(): print(&quot;I&apos;m working...&quot;)schedule.every(10).minutes.do(job)# 每10分钟执行一次schedule.every().hour.do(job)# 每小时执行一次schedule.every().day.at(&quot;10:30&quot;).do(job)# 每天的10：30执行一次schedule.every().monday.do(job)# 每周一执行一次schedule.every().wednesday.at(&quot;13:14&quot;).do(job)# 每个星期三的13：14分执行一次# 在job后面直接加参数即可传参‘，’分隔while True: schedule.run_pending() time.sleep(1)# time.sleep(1)这里就是我运行时发现麻烦的地方！# 不sleep他就会一直占用cpu运行判断是否到了执行时间 使用APscheduler安装包的包名就是apscheduler 引入包1from apscheduler.schedulers.blocking import BlockingScheduler 使用方式这里只写了执行的流程123456# 初始化sche = BlockingScheduler()# 增加任务sche.add_job(任务)# 执行sche.start() 定义执行的任务这个是要在定时任务里执行的方法（函数）123def my_job(str_msg): # 定义执行的任务 print(&quot;hello run!!!!&quot;,str_msg) 增加间隔式的任务间隔式任务我这里是指不管现实的时间，只管运行时间12345# 参数（函数名，类型，关键字参数）sched.add_job(my_job, &apos;interval&apos;, seconds=20, args=(&quot;seconds 20&quot;,))# 每隔20秒运行sched.add_job(my_job, &apos;interval&apos;,hours=1, minutes=1, seconds=1, args=(&quot;minute 1 seconds 1&quot;,))# 每隔一个小时一分一秒运行 增加定时式的任务定时任务是指与现实时间挂钩1234sched.add_job(my_job, &apos;cron&apos;, second=11, args=(&quot;every second 11&quot;,))# 每分钟的11ssched.add_job(my_job, &apos;cron&apos;, minute=3, args=(&quot;ever minute 3&quot;,))# 每小时的第3分钟 更多的参数请参考本文参考地址：(https://www.cnblogs.com/luxiaojun/p/6567132.html#[3990018])]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hasattr 对字典使用无效]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%AF%B9dict%E4%BD%BF%E7%94%A8hasattr%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[原因今天在判断字典的内容的时候使用了hasattr来判断字典中是否有这个key1hasattr(dict,key) 这样做是错误的，在运行时无法达到我所预期的效果 正确的做法：1key in dict.keys() 由于自己已经这样用了多次，记录一下提醒自己]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>errorUse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Explain]]></title>
    <url>%2F2018%2F07%2F31%2FExplain%2F</url>
    <content type="text"><![CDATA[个人速写编程语言： 在校期间使用：java 工作时使用： python使用过的框架： Java spring spring-mvc mybatis python django uwsgi Nginx djangoRESTframework开始写博客时间 2018-07-30 学习经历2018 毕业于湖南师范大学 工作工作单位：深圳兴导科技工作时间：2018.06.13-至今]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python sorted compare]]></title>
    <url>%2F2018%2F07%2F31%2Fpython-sorted-and-obj-sorted-compare%2F</url>
    <content type="text"><![CDATA[MySortDataNow that I have some data and need to sort it, I need to find a faster sorting method in the sorting method.Data as shown below:1data = &#123;1:&#123;'total_score':50, 'compare_score':49, 'name':'roc'&#125;,.....&#125; The above is a set of data, and I need to sort them according to the score fieldin the dictionary Compare sorted() obj.sort()I try sorted() Methon:1result = sorted(data.items(), key=lambda x:x[1]['total_score'], reverse=True) OK! I get the result! it’s average run time is : 7.5841E-06And I try obj.sort() Methon:1result.sort(key=lambda x:x['compare_score'], reverse=True) it’s average run time is : 6.5666E-06This result doesn’t seem to make any difference Use itemgetterBecause of my depth of listing, I can’t use itemgetter directly. So first define it123get_position = itemgetter(1) # get index 1get_compare = itemgetter('compare_score') # get compare_score dataget_total = itemgetter('total_score') # get total_score data Now use sorted():1result = sorted(data.items(), key=lambda x: get_total(get_position(x)), reverse=True) Average run time: 1.18327E-05?????????????????? See sort():1result.sort(key=lambda x: get_compare(get_position(x)), reverse=True) Average run time: 1.01018E-05 SummaryFrom the above results, we can see that there is not much difference between using sorted () and using obj. sort (), and obj. sort () may be a little bit faster. But the speed difference with itemgetter is very large.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to [Hexo] This is your very first post. Check [documentation] for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting] or you can ask me on [GitHub] Quick StartCreate a new post1$ hexo new "My New Post" More info: [Writing] Run server1$ hexo server More info: [Server] Generate static files1$ hexo generate More info: [Generating] Deploy to remote sites1$ hexo deploy More info: [Deployment]]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
